(function(L,M){typeof exports=="object"&&typeof module<"u"?module.exports=M():typeof define=="function"&&define.amd?define(M):(L=typeof globalThis<"u"?globalThis:L||self,L.CesiumPlot=M())})(this,function(){"use strict";var pt=Object.defineProperty;var yt=(L,M,A)=>M in L?pt(L,M,{enumerable:!0,configurable:!0,writable:!0,value:A}):L[M]=A;var l=(L,M,A)=>(yt(L,typeof M!="symbol"?M+"":M,A),A);class L{constructor(){l(this,"listeners");this.listeners=new Map([["drawStart",new Set],["drawUpdate",new Set],["drawEnd",new Set],["editStart",new Set],["editEnd",new Set]])}on(i,t){if(!this.listeners.has(i)){console.warn("Event binding must be one of 'drawStart', 'drawUpdate', or 'drawEnd'.");return}this.listeners.get(i).add(t)}off(i,t){this.listeners.has(i)&&this.listeners.get(i).delete(t)}dispatchEvent(i,t){this.listeners.has(i)&&this.listeners.get(i).forEach(e=>{e(t)})}}class M{constructor(i,t,e){l(this,"cesium");l(this,"viewer");l(this,"eventHandler");l(this,"polygonEntity");l(this,"geometryPoints",[]);l(this,"state","drawing");l(this,"controlPoints",[]);l(this,"controlPointsEventHandler");l(this,"lineEntity");l(this,"type");l(this,"freehand");l(this,"style");l(this,"outlineEntity");l(this,"eventDispatcher");l(this,"dragEventHandler");l(this,"entityId","");l(this,"points",[]);this.cesium=i,this.viewer=t,this.type=this.getType(),this.mergeStyle(e),this.cartesianToLnglat=this.cartesianToLnglat.bind(this),this.pixelToCartesian=this.pixelToCartesian.bind(this),this.eventDispatcher=new L,this.onClick()}mergeStyle(i){this.type==="polygon"?this.style=Object.assign({material:this.cesium.Color.fromCssColorString("rgba(59, 178, 208, 0.2)"),outlineMaterial:this.cesium.Color.fromCssColorString("rgba(59, 178, 208, 1.0)"),outlineWidth:2},i):this.type==="line"&&(this.style=Object.assign({material:this.cesium.Color.fromCssColorString("rgba(59, 178, 208, 1.0)"),lineWidth:2},i))}setState(i){this.state=i}getState(){return this.state}onClick(){this.eventHandler=new this.cesium.ScreenSpaceEventHandler(this.viewer.canvas),this.eventHandler.setInputAction(i=>{const t=this.viewer.scene.pick(i.position),e=this.cesium.defined(t)&&t.id instanceof this.cesium.Entity;let s=this.polygonEntity;if(this.type==="line"&&(s=this.lineEntity),this.state==="drawing"){const n=this.pixelToCartesian(i.position),o=this.getPoints();if(!n||!this.freehand&&o.length>0&&!this.checkDistance(n,o[o.length-1]))return;this.addPoint(n),this.getPoints().length===1&&this.eventDispatcher.dispatchEvent("drawStart"),this.eventDispatcher.dispatchEvent("drawUpdate",n)}else if(this.state==="edit")(!e||s.id!==t.id.id)&&(this.setState("static"),this.removeControlPoints(),this.disableDrag(),this.eventDispatcher.dispatchEvent("drawEnd",this.getPoints()));else if(this.state==="static"&&e&&s.id===t.id.id){const n=this.type==="line"?t.id.polyline:t.id.polygon;this.cesium.defined(n)&&(this.setState("edit"),this.addControlPoints(),this.draggable(),this.eventDispatcher.dispatchEvent("editStart"))}},this.cesium.ScreenSpaceEventType.LEFT_CLICK)}onMouseMove(){this.eventHandler.setInputAction(i=>{const t=this.getPoints(),e=this.pixelToCartesian(i.endPosition);e&&this.checkDistance(e,t[t.length-1])&&this.updateMovingPoint(e,t.length)},this.cesium.ScreenSpaceEventType.MOUSE_MOVE)}onDoubleClick(){this.eventHandler.setInputAction(i=>{this.state==="drawing"&&this.finishDrawing()},this.cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK)}checkDistance(i,t){return this.cesium.Cartesian3.distance(i,t)>10}finishDrawing(){this.removeMoveListener(),this.setState("edit"),this.addControlPoints(),this.draggable();const i=this.polygonEntity||this.lineEntity;this.entityId=i.id,this.eventDispatcher.dispatchEvent("drawEnd",this.getPoints())}removeClickListener(){this.eventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_CLICK)}removeMoveListener(){this.eventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.MOUSE_MOVE)}removeDoubleClickListener(){this.eventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK)}setGeometryPoints(i){this.geometryPoints=i}getGeometryPoints(){return this.geometryPoints}drawPolygon(){const i=()=>new this.cesium.PolygonHierarchy(this.geometryPoints);if(!this.polygonEntity){const t=this.style;this.polygonEntity=this.viewer.entities.add({polygon:new this.cesium.PolygonGraphics({hierarchy:new this.cesium.CallbackProperty(i,!1),show:!0,material:t.material})}),this.outlineEntity=this.viewer.entities.add({polyline:{positions:new this.cesium.CallbackProperty(()=>[...this.geometryPoints,this.geometryPoints[0]],!1),width:t.outlineWidth,material:t.outlineMaterial,clampToGround:!0}})}}drawLine(){if(!this.lineEntity){const i=this.style;this.lineEntity=this.addLineEntity(i)}}addFirstLineOfTheArrow(){if(!this.lineEntity){const i=this.style,t={material:i.outlineMaterial,lineWidth:i.outlineWidth};this.lineEntity=this.addLineEntity(t)}}addLineEntity(i){return this.viewer.entities.add({polyline:{positions:new this.cesium.CallbackProperty(()=>this.geometryPoints,!1),width:i.lineWidth,material:i.material,clampToGround:!0}})}cartesianToLnglat(i){const t=this.viewer.scene.globe.ellipsoid.cartesianToCartographic(i),e=this.cesium.Math.toDegrees(t.latitude);return[this.cesium.Math.toDegrees(t.longitude),e]}pixelToCartesian(i){const t=this.viewer.camera.getPickRay(i);return this.viewer.scene.globe.pick(t,this.viewer.scene)}addControlPoints(){const i=this.getPoints();this.controlPoints=i.map(n=>this.viewer.entities.add({position:n,point:{pixelSize:10,heightReference:this.cesium.HeightReference.CLAMP_TO_GROUND,color:this.cesium.Color.RED}}));let t=!1,e=null,s;this.controlPointsEventHandler=new this.cesium.ScreenSpaceEventHandler(this.viewer.canvas),this.controlPointsEventHandler.setInputAction(n=>{const o=this.viewer.scene.pick(n.position);if(this.cesium.defined(o)){for(let a=0;a<this.controlPoints.length;a++)if(o.id===this.controlPoints[a]){t=!0,e=this.controlPoints[a],s=e.position._value,e.index=a;break}this.viewer.scene.screenSpaceCameraController.enableRotate=!1}},this.cesium.ScreenSpaceEventType.LEFT_DOWN),this.controlPointsEventHandler.setInputAction(n=>{if(t&&e){const o=this.viewer.camera.pickEllipsoid(n.endPosition,this.viewer.scene.globe.ellipsoid);o&&(e.position.setValue(o),this.updateDraggingPoint(o,e.index))}},this.cesium.ScreenSpaceEventType.MOUSE_MOVE),this.controlPointsEventHandler.setInputAction(()=>{e&&!this.cesium.Cartesian3.equals(s,e.position._value)&&this.eventDispatcher.dispatchEvent("drawUpdate",e.position._value),t=!1,e=null,this.viewer.scene.screenSpaceCameraController.enableRotate=!0},this.cesium.ScreenSpaceEventType.LEFT_UP)}removeControlPoints(){this.controlPoints.length>0&&(this.controlPoints.forEach(i=>{this.viewer.entities.remove(i)}),this.controlPointsEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_DOWN),this.controlPointsEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.MOUSE_MOVE),this.controlPointsEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_UP))}draggable(){let i=!1,t;this.dragEventHandler=new this.cesium.ScreenSpaceEventHandler(this.viewer.canvas),this.dragEventHandler.setInputAction(e=>{const s=this.viewer.scene.camera.getPickRay(e.position);if(s){const n=this.viewer.scene.globe.pick(s,this.viewer.scene),o=this.viewer.scene.pick(e.position);if(this.cesium.defined(o)&&o.id instanceof this.cesium.Entity){const a=o.id;this.isCurrentEntity(a.id)&&(i=!0,t=n,this.viewer.scene.screenSpaceCameraController.enableRotate=!1)}}},this.cesium.ScreenSpaceEventType.LEFT_DOWN),this.dragEventHandler.setInputAction(e=>{if(i&&t){const s=this.pixelToCartesian(e.endPosition);if(s){const n=this.cesium.Cartesian3.subtract(s,t,new this.cesium.Cartesian3),o=this.geometryPoints.map(a=>this.cesium.Cartesian3.add(a,n,new this.cesium.Cartesian3));this.points=this.points.map(a=>this.cesium.Cartesian3.add(a,n,new this.cesium.Cartesian3)),this.controlPoints.map(a=>{var g,d;const h=(g=a.position)==null?void 0:g.getValue(this.cesium.JulianDate.now()),c=this.cesium.Cartesian3.add(h,n,new this.cesium.Cartesian3);(d=a.position)==null||d.setValue(c)}),this.setGeometryPoints(o),t=s}}else if(this.viewer.scene.camera.getPickRay(e.endPosition)){const n=this.viewer.scene.pick(e.endPosition);if(this.cesium.defined(n)&&n.id instanceof this.cesium.Entity){const o=n.id;this.isCurrentEntity(o.id)?this.viewer.scene.canvas.style.cursor="move":this.viewer.scene.canvas.style.cursor="default"}else this.viewer.scene.canvas.style.cursor="default"}},this.cesium.ScreenSpaceEventType.MOUSE_MOVE),this.dragEventHandler.setInputAction(()=>{i=!1,t=void 0,this.viewer.scene.screenSpaceCameraController.enableRotate=!0},this.cesium.ScreenSpaceEventType.LEFT_UP)}disableDrag(){this.dragEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_DOWN),this.dragEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.MOUSE_MOVE),this.dragEventHandler.removeInputAction(this.cesium.ScreenSpaceEventType.LEFT_UP)}show(){this.type==="polygon"?(this.polygonEntity.show=!0,this.outlineEntity.polyline.clampToGround=!0,this.outlineEntity.show=!0):this.type==="line"&&(this.lineEntity.polyline.clampToGround=!0,this.lineEntity.show=!0)}hide(){this.type==="polygon"?(this.polygonEntity.show=!1,this.outlineEntity.polyline.clampToGround=!1,this.outlineEntity.show=!1):this.type==="line"&&(this.lineEntity.polyline.clampToGround=!1,this.lineEntity.show=!1)}remove(){this.type==="polygon"?(this.viewer.entities.remove(this.polygonEntity),this.viewer.entities.remove(this.outlineEntity)):this.type==="line"&&this.viewer.entities.remove(this.lineEntity),this.removeClickListener(),this.removeMoveListener(),this.removeDoubleClickListener(),this.removeControlPoints()}on(i,t){this.eventDispatcher.on(i,t)}off(i,t){this.eventDispatcher.off(i,t)}isCurrentEntity(i){return this.entityId===i}addPoint(i){}getPoints(){return[new this.cesium.Cartesian3]}updateMovingPoint(i,t){}updateDraggingPoint(i,t){}getType(){return"polygon"}}const A=100,x=1e-4,E=(r,i)=>Math.sqrt((r[0]-i[0])**2+(r[1]-i[1])**2),H=r=>{let i=0;return r&&Array.isArray(r)&&r.length>0&&r.forEach((t,e)=>{e<r.length-1&&(i+=E(t,r[e+1]))}),i},T=r=>H(r)**.99,F=(r,i)=>[(r[0]+i[0])/2,(r[1]+i[1])/2],j=(r,i,t)=>{const e=[(r[0]+i[0])/2,(r[1]+i[1])/2],s=[e[0]-r[1]+i[1],e[1]+r[0]-i[0]],n=[(r[0]+t[0])/2,(r[1]+t[1])/2],o=[n[0]-r[1]+t[1],n[1]+r[0]-t[0]];return q(e,s,n,o)},q=(r,i,t,e)=>{if(r[1]===i[1]){const c=(e[0]-t[0])/(e[1]-t[1])*(r[1]-t[1])+t[0],g=r[1];return[c,g]}if(t[1]===e[1]){const c=(i[0]-r[0])/(i[1]-r[1])*(t[1]-r[1])+r[0],g=t[1];return[c,g]}const s=(i[0]-r[0])/(i[1]-r[1]),n=(e[0]-t[0])/(e[1]-t[1]),o=(s*r[1]-r[0]-n*t[1]+t[0])/(s-n);return[s*o-s*r[1]+r[0],o]},W=(r,i)=>{let t;const e=Math.asin(Math.abs(i[1]-r[1])/E(r,i));return i[1]>=r[1]&&i[0]>=r[0]?t=e+Math.PI:i[1]>=r[1]&&i[0]<r[0]?t=Math.PI*2-e:i[1]<r[1]&&i[0]<r[0]?t=e:i[1]<r[1]&&i[0]>=r[0]&&(t=Math.PI-e),t},G=(r,i,t)=>{const e=W(i,r)-W(i,t);return e<0?e+Math.PI*2:e},b=(r,i,t)=>(t[1]-r[1])*(i[0]-r[0])>(i[1]-r[1])*(t[0]-r[0]),z=(r,i,t,e,s)=>{r=Math.max(Math.min(r,1),0);const[n,o]=[1-r,r*r],a=o*r,h=n*n,c=h*n,g=c*i[0]+3*h*r*t[0]+3*n*o*e[0]+a*s[0],d=c*i[1]+3*h*r*t[1]+3*n*o*e[1]+a*s[1];return[g,d]},P=(r,i,t,e,s)=>{const n=W(r,i),o=s?n+t:n-t,a=e*Math.cos(o),h=e*Math.sin(o);return[i[0]+a,i[1]+h]},K=(r,i,t,e)=>{let[s,n,o,a]=[null,null,[],e-t];a=a<0?a+Math.PI*2:a;for(let h=0;h<=100;h++){const c=t+a*h/100;s=r[0]+i*Math.cos(c),n=r[1]+i*Math.sin(c),o.push([s,n])}return o},R=(r,i,t,e)=>{const s=O(i,t,e);let[n,o,a,h,c]=[null,null,null,null,null];const g=Math.sqrt(s[0]*s[0]+s[1]*s[1]),d=s[0]/g,p=s[1]/g,m=E(i,t),u=E(t,e);return g>x?b(i,t,e)?(a=r*m,h=t[0]-a*p,c=t[1]+a*d,n=[h,c],a=r*u,h=t[0]+a*p,c=t[1]-a*d,o=[h,c]):(a=r*m,h=t[0]+a*p,c=t[1]-a*d,n=[h,c],a=r*u,h=t[0]-a*p,c=t[1]+a*d,o=[h,c]):(h=t[0]+r*(i[0]-t[0]),c=t[1]+r*(i[1]-t[1]),n=[h,c],h=t[0]+r*(e[0]-t[0]),c=t[1]+r*(e[1]-t[1]),o=[h,c]),[n,o]},O=(r,i,t)=>{let e=r[0]-i[0],s=r[1]-i[1];const n=Math.sqrt(e*e+s*s);e/=n,s/=n;let o=t[0]-i[0],a=t[1]-i[1];const h=Math.sqrt(o*o+a*a);o/=h,a/=h;const c=e+o,g=s+a;return[c,g]},Q=(r,i)=>{let[t,e,s,n,o]=[r[0],r[1],r[2],null,null];const h=R(0,t,e,s)[0],c=O(t,e,s);if(Math.sqrt(c[0]*c[0]+c[1]*c[1])>x){const d=F(t,e),p=t[0]-d[0],m=t[1]-d[1],y=2/E(t,e),f=-y*m,w=y*p,v=f*f-w*w,k=2*f*w,I=w*w-f*f,D=h[0]-d[0],S=h[1]-d[1];n=d[0]+v*D+k*S,o=d[1]+k*D+I*S}else n=t[0]+i*(e[0]-t[0]),o=t[1]+i*(e[1]-t[1]);return[n,o]},J=(r,i)=>{const t=r.length,e=r[t-3],s=r[t-2],n=r[t-1],a=R(0,e,s,n)[1],h=O(e,s,n),c=Math.sqrt(h[0]*h[0]+h[1]*h[1]);let[g,d]=[null,null];if(c>x){const p=F(s,n),m=n[0]-p[0],u=n[1]-p[1],f=2/E(s,n),w=-f*u,v=f*m,k=w*w-v*v,I=2*w*v,D=v*v-w*w,S=a[0]-p[0],V=a[1]-p[1];g=p[0]+k*S+I*V,d=p[1]+I*S+D*V}else g=n[0]+i*(s[0]-n[0]),d=n[1]+i*(s[1]-n[1]);return[g,d]},N=(r,i)=>{const t=Q(i,r);let[e,s,n,o,a]=[null,null,null,[t],[]];for(let c=0;c<i.length-2;c++){[e,s,n]=[i[c],i[c+1],i[c+2]];const g=R(r,e,s,n);o=o.concat(g)}const h=J(i,r);h&&o.push(h);for(let c=0;c<i.length-1;c++){e=i[c],s=i[c+1],a.push(e);for(let g=0;g<A;g++){const d=z(g/A,e,o[c*2],o[c*2+1],s);a.push(d)}a.push(s)}return a},_=function(r){if(r.length<=2)return r;const i=[],t=r.length-1;for(let e=0;e<=1;e+=.01){let[s,n]=[0,0];for(let o=0;o<=t;o++){const a=Z(t,o),h=e**o,c=(1-e)**(t-o);s+=a*h*c*r[o][0],n+=a*h*c*r[o][1]}i.push([s,n])}return i.push(r[t]),i},B=r=>{let i=1;switch(r){case r<=1:i=1;break;case r===2:i=2;break;case r===3:i=6;break;case r===24:i=24;break;case r===5:i=120;break;default:for(let t=1;t<=r;t++)i*=t;break}return i},Z=(r,i)=>B(r)/(B(i)*B(r-i)),C=r=>{if(r.length<=2)return r;const[i,t]=[2,[]],e=r.length-i-1;t.push(r[0]);for(let s=0;s<=e;s++)for(let n=0;n<=1;n+=.05){let[o,a]=[0,0];for(let h=0;h<=i;h++){const c=$(h,n);o+=c*r[s+h][0],a+=c*r[s+h][1]}t.push([o,a])}return t.push(r[r.length-1]),t},$=(r,i)=>{let t=0;return r===0?t=(i-1)**2/2:r===1?t=(-2*i**2+2*i+1)/2:r===2&&(t=i**2/2),t};class X extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",2);l(this,"tailWidthFactor");l(this,"neckWidthFactor");l(this,"headWidthFactor");l(this,"headAngle");l(this,"neckAngle");this.cesium=t,this.tailWidthFactor=.1,this.neckWidthFactor=.2,this.headWidthFactor=.25,this.headAngle=Math.PI/8.5,this.neckAngle=Math.PI/13,this.setState("drawing")}getType(){return"polygon"}addPoint(t){if(this.points.length<2&&(this.points.push(t),this.onMouseMove()),this.points.length===2){const e=this.createPolygon(this.points);this.setGeometryPoints(e),this.drawPolygon(),this.finishDrawing()}}updateMovingPoint(t){const e=[...this.points,t],s=this.createPolygon(e);this.setGeometryPoints(s),this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createPolygon(this.points);this.setGeometryPoints(s),this.drawPolygon()}createPolygon(t){const[e,s]=t.map(this.cartesianToLnglat),n=T([e,s]),o=n*this.tailWidthFactor,a=n*this.neckWidthFactor,h=n*this.headWidthFactor,c=P(s,e,Math.PI/2,o,!0),g=P(s,e,Math.PI/2,o,!1),d=P(e,s,this.headAngle,h,!1),p=P(e,s,this.headAngle,h,!0),m=P(e,s,this.neckAngle,a,!1),u=P(e,s,this.neckAngle,a,!0),y=[...c,...m,...d,...s,...p,...u,...g,...e];return this.cesium.Cartesian3.fromDegreesArray(y)}getPoints(){return this.points}}class U extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"headHeightFactor");l(this,"headWidthFactor");l(this,"neckHeightFactor");l(this,"neckWidthFactor");l(this,"headTailFactor");this.cesium=t,this.headHeightFactor=.18,this.headWidthFactor=.3,this.neckHeightFactor=.85,this.neckWidthFactor=.15,this.headTailFactor=.8,this.setState("drawing"),this.onDoubleClick()}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.points.length===2?(this.setGeometryPoints(this.points),this.drawPolygon()):this.lineEntity&&this.viewer.entities.remove(this.lineEntity)}updateMovingPoint(t){const e=[...this.points,t];if(this.setGeometryPoints(e),e.length===2)this.addFirstLineOfTheArrow();else{const s=this.createPolygon(e);this.setGeometryPoints(s),this.drawPolygon()}}createPolygon(t){const e=t.map(k=>this.cartesianToLnglat(k));let[s,n]=[e[0],e[1]];b(e[0],e[1],e[2])&&(s=e[1],n=e[0]);const a=[F(s,n)].concat(e.slice(2)),h=this.getArrowHeadPoints(a,s,n),[c,g]=[h[0],h[4]],d=E(s,n)/T(a),p=this.getArrowBodyPoints(a,c,g,d),m=p.length;let u=[s].concat(p.slice(0,m/2));u.push(c);let y=[n].concat(p.slice(m/2,m));y.push(g),u=C(u),y=C(y);const f=u.concat(h,y.reverse()),w=[].concat(...f);return this.cesium.Cartesian3.fromDegreesArray(w)}getPoints(){return this.points}getArrowHeadPoints(t,e,s){try{let n=T(t),o=n*this.headHeightFactor;const a=t[t.length-1];n=E(a,t[t.length-2]);const h=E(e,s);o>h*this.headTailFactor&&(o=h*this.headTailFactor);const c=o*this.headWidthFactor,g=o*this.neckWidthFactor;o=o>n?n:o;const d=o*this.neckHeightFactor,p=P(t[t.length-2],a,0,o,!0),m=P(t[t.length-2],a,0,d,!0),u=P(a,p,Math.PI/2,c,!1),y=P(a,p,Math.PI/2,c,!0),f=P(a,m,Math.PI/2,g,!1),w=P(a,m,Math.PI/2,g,!0);return[f,u,a,y,w]}catch(n){console.log(n)}}getArrowBodyPoints(t,e,s,n){const o=H(t),h=T(t)*n,c=E(e,s),g=(h-c)/2;let[d,p,m]=[0,[],[]];for(let u=1;u<t.length-1;u++){const y=G(t[u-1],t[u],t[u+1])/2;d+=E(t[u-1],t[u]);const f=(h/2-d/o*g)/Math.sin(y),w=P(t[u-1],t[u],Math.PI-y,f,!0),v=P(t[u-1],t[u],y,f,!1);p.push(w),m.push(v)}return p.concat(m)}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createPolygon(this.points);this.setGeometryPoints(s),this.drawPolygon()}}class tt extends U{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"headHeightFactor");l(this,"headWidthFactor");l(this,"neckHeightFactor");l(this,"neckWidthFactor");l(this,"headTailFactor");l(this,"tailWidthFactor");l(this,"swallowTailFactor");l(this,"swallowTailPnt");this.cesium=t,this.headHeightFactor=.18,this.headWidthFactor=.3,this.neckHeightFactor=.85,this.neckWidthFactor=.15,this.tailWidthFactor=.1,this.headTailFactor=.8,this.swallowTailFactor=1,this.swallowTailPnt=[0,0]}createPolygon(t){const e=t.map(S=>this.cartesianToLnglat(S));let[s,n]=[e[0],e[1]];b(e[0],e[1],e[2])&&(s=e[1],n=e[0]);const a=[F(s,n)].concat(e.slice(2)),h=this.getArrowHeadPoints(a,s,n),[c,g]=[h[0],h[4]],d=E(s,n),p=T(a),m=p*this.tailWidthFactor*this.swallowTailFactor;this.swallowTailPnt=P(a[1],a[0],0,m,!0);const u=d/p,y=this.getArrowBodyPoints(a,c,g,u),f=y.length;let w=[s].concat(y.slice(0,f/2));w.push(c);let v=[n].concat(y.slice(f/2,f));v.push(g),w=C(w),v=C(v);const k=w.concat(h,v.reverse(),[this.swallowTailPnt,w[0]]),I=[].concat(...k);return this.cesium.Cartesian3.fromDegreesArray(I)}}class Y extends U{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"headHeightFactor");l(this,"headWidthFactor");l(this,"neckHeightFactor");l(this,"neckWidthFactor");l(this,"tailWidthFactor");this.cesium=t,this.headHeightFactor=.18,this.headWidthFactor=.3,this.neckHeightFactor=.85,this.neckWidthFactor=.15,this.tailWidthFactor=.1}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.points.length>2&&this.lineEntity&&this.viewer.entities.remove(this.lineEntity)}updateMovingPoint(t){const e=[...this.points,t];if(this.setGeometryPoints(e),!(e.length<2)){const s=this.createPolygon(e);this.setGeometryPoints(s),this.drawPolygon()}}createPolygon(t){const e=t.map(y=>this.cartesianToLnglat(y)),s=this.getTailPoints(e),n=this.getArrowHeadPoints(e,s[0],s[1]),o=n[0],a=n[4],h=this.getArrowBodyPoints(e,o,a,this.tailWidthFactor),c=h.length;let g=[s[0]].concat(h.slice(0,c/2));g.push(o);let d=[s[1]].concat(h.slice(c/2,c));d.push(a),g=C(g),d=C(d);const p=g.concat(n,d.reverse()),m=[].concat(...p);return this.cesium.Cartesian3.fromDegreesArray(m)}getTailPoints(t){const s=T(t)*this.tailWidthFactor,n=P(t[1],t[0],Math.PI/2,s,!1),o=P(t[1],t[0],Math.PI/2,s,!0);return[n,o]}}class et extends Y{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"headHeightFactor");l(this,"headWidthFactor");l(this,"neckHeightFactor");l(this,"neckWidthFactor");l(this,"tailWidthFactor");l(this,"swallowTailFactor");this.cesium=t,this.headHeightFactor=.18,this.headWidthFactor=.3,this.neckHeightFactor=.85,this.neckWidthFactor=.15,this.tailWidthFactor=.1,this.swallowTailFactor=1}createPolygon(t){const e=t.map(y=>this.cartesianToLnglat(y)),s=this.getTailPoints(e),n=this.getArrowHeadPoints(e,s[0],s[2]),o=n[0],a=n[4],h=this.getArrowBodyPoints(e,o,a,this.tailWidthFactor),c=h.length;let g=[s[0]].concat(h.slice(0,c/2));g.push(o);let d=[s[2]].concat(h.slice(c/2,c));d.push(a),g=C(g),d=C(d);const p=g.concat(n,d.reverse(),[s[1],g[0]]),m=[].concat(...p);return this.cesium.Cartesian3.fromDegreesArray(m)}getTailPoints(t){const s=T(t)*this.tailWidthFactor,n=P(t[1],t[0],Math.PI/2,s,!1),o=P(t[1],t[0],Math.PI/2,s,!0),a=s*this.swallowTailFactor,h=P(t[1],t[0],0,a,!0);return[n,h,o]}}class st extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",3e6);this.cesium=t,this.setState("drawing")}getType(){return"line"}addPoint(t){if(this.points.length<2&&(this.points.push(t),this.onMouseMove()),this.points.length===2){const e=this.createLine(this.points);this.setGeometryPoints(e),this.drawLine(),this.finishDrawing()}}updateMovingPoint(t){const e=[...this.points,t],s=this.createLine(e);this.setGeometryPoints(s),this.drawLine()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createLine(this.points);this.setGeometryPoints(s),this.drawLine()}createLine(t){const[e,s]=t.map(this.cartesianToLnglat);let o=E(e,s)/this.arrowLengthScale;o=o>this.maxArrowLength?this.maxArrowLength:o;const a=P(e,s,Math.PI/6,o,!1),h=P(e,s,Math.PI/6,o,!0),c=[...e,...s,...a,...s,...h];return this.cesium.Cartesian3.fromDegreesArray(c)}getPoints(){return this.points}}class it extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",3e6);l(this,"t");this.cesium=t,this.t=.3,this.setState("drawing"),this.onDoubleClick()}getType(){return"line"}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.points.length===2&&(this.setGeometryPoints(this.points),this.drawLine())}updateMovingPoint(t){const e=[...this.points,t];let s=[];e.length===2?s=this.createStraightArrow(e):s=this.createLine(e),this.setGeometryPoints(s),this.drawLine()}createStraightArrow(t){const[e,s]=t.map(this.cartesianToLnglat);let o=E(e,s)/this.arrowLengthScale;o=o>this.maxArrowLength?this.maxArrowLength:o;const a=P(e,s,Math.PI/6,o,!1),h=P(e,s,Math.PI/6,o,!0),c=[...e,...s,...a,...s,...h];return this.cesium.Cartesian3.fromDegreesArray(c)}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createLine(this.points);this.setGeometryPoints(s),this.drawLine()}createLine(t){const e=t.map(u=>this.cartesianToLnglat(u)),s=N(this.t,e),n=e[e.length-2],o=e[e.length-1];let h=H(e)/this.arrowLengthScale;h=h>this.maxArrowLength?this.maxArrowLength:h;const c=P(n,o,Math.PI/6,h,!1),g=P(n,o,Math.PI/6,h,!0),p=[...[].concat(...s),...c,...o,...g];return this.cesium.Cartesian3.fromDegreesArray(p)}getPoints(){return this.points}}class nt extends X{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",2);l(this,"tailWidthFactor");l(this,"neckWidthFactor");l(this,"headWidthFactor");l(this,"headAngle");l(this,"neckAngle");this.cesium=t,this.tailWidthFactor=.08,this.neckWidthFactor=.1,this.headWidthFactor=.13,this.headAngle=Math.PI/4,this.neckAngle=Math.PI*.17741,this.setState("drawing")}createPolygon(t){const[e,s]=t.map(this.cartesianToLnglat),n=T([e,s])*1.5,o=n*this.tailWidthFactor,a=n*this.neckWidthFactor,h=n*this.headWidthFactor,c=P(s,e,Math.PI/2,o,!0),g=P(s,e,Math.PI/2,o,!1),d=P(e,s,this.headAngle,h,!1),p=P(e,s,this.headAngle,h,!0),m=P(e,s,this.neckAngle,a,!1),u=P(e,s,this.neckAngle,a,!0),y=[...c,...m,...d,...s,...p,...u,...g,...e];return this.cesium.Cartesian3.fromDegreesArray(y)}}class ot extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",2);l(this,"neckWidthFactor");l(this,"headWidthFactor");l(this,"headHeightFactor");l(this,"neckHeightFactor");l(this,"connPoint");l(this,"tempPoint4");this.cesium=t,this.headHeightFactor=.25,this.headWidthFactor=.3,this.neckHeightFactor=.85,this.neckWidthFactor=.15,this.connPoint=[0,0],this.tempPoint4=[0,0],this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.points.length===2?(this.setGeometryPoints(this.points),this.drawPolygon()):this.points.length===3?this.lineEntity&&this.viewer.entities.remove(this.lineEntity):this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t];if(this.setGeometryPoints(e),e.length===2)this.addFirstLineOfTheArrow();else if(e.length>2){const s=this.createPolygon(e);this.setGeometryPoints(s),this.drawPolygon()}}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createPolygon(this.points);this.setGeometryPoints(s),this.drawPolygon()}createPolygon(t){const e=t.map(S=>this.cartesianToLnglat(S)),[s,n,o]=[e[0],e[1],e[2]],a=e.length;a===3?(this.tempPoint4=this.getTempPoint4(s,n,o),this.connPoint=F(s,n)):a===4?(this.tempPoint4=e[3],this.connPoint=F(s,n)):(this.tempPoint4=e[3],this.connPoint=e[4]);let h,c;b(s,n,o)?(h=this.getArrowPoints(s,this.connPoint,this.tempPoint4,!1),c=this.getArrowPoints(this.connPoint,n,o,!0)):(h=this.getArrowPoints(n,this.connPoint,o,!1),c=this.getArrowPoints(this.connPoint,s,this.tempPoint4,!0));const g=h.length,d=(g-5)/2,p=h.slice(0,d),m=h.slice(d,d+5);let u=h.slice(d+5,g),y=c.slice(0,d);const f=c.slice(d,d+5),w=c.slice(d+5,g);y=_(y);const v=_(w.concat(p.slice(1)));u=_(u);const k=y.concat(f,v,m,u),I=[].concat(...k);return this.cesium.Cartesian3.fromDegreesArray(I)}getTempPoint4(t,e,s){const n=F(t,e),o=E(n,s),a=G(t,n,s);let h=[0,0],c,g,d;return a<Math.PI/2?(c=o*Math.sin(a),g=o*Math.cos(a),d=P(t,n,Math.PI/2,c,!1),h=P(n,d,Math.PI/2,g,!0)):a>=Math.PI/2&&a<Math.PI?(c=o*Math.sin(Math.PI-a),g=o*Math.cos(Math.PI-a),d=P(t,n,Math.PI/2,c,!1),h=P(n,d,Math.PI/2,g,!1)):a>=Math.PI&&a<Math.PI*1.5?(c=o*Math.sin(a-Math.PI),g=o*Math.cos(a-Math.PI),d=P(t,n,Math.PI/2,c,!0),h=P(n,d,Math.PI/2,g,!0)):(c=o*Math.sin(Math.PI*2-a),g=o*Math.cos(Math.PI*2-a),d=P(t,n,Math.PI/2,c,!0),h=P(n,d,Math.PI/2,g,!1)),h}getArrowPoints(t,e,s,n){const o=F(t,e),a=E(o,s);let h=P(s,o,0,a*.3,!0),c=P(s,o,0,a*.5,!0);h=P(o,h,Math.PI/2,a/5,n),c=P(o,c,Math.PI/2,a/4,n);const g=[o,h,c,s],d=this.getArrowHeadPoints(g);if(d&&Array.isArray(d)&&d.length>0){const p=d[0],m=d[4],u=E(t,e)/T(g)/2,y=this.getArrowBodyPoints(g,p,m,u);if(y){const f=y.length;let w=y.slice(0,f/2),v=y.slice(f/2,f);return w.push(p),v.push(m),w=w.reverse(),w.push(e),v=v.reverse(),v.push(t),w.reverse().concat(d,v)}}else throw new Error("Interpolation Error")}getArrowBodyPoints(t,e,s,n){const o=H(t),h=T(t)*n,c=E(e,s),g=(h-c)/2;let d=0,p=[],m=[];for(let u=1;u<t.length-1;u++){const y=G(t[u-1],t[u],t[u+1])/2;d+=E(t[u-1],t[u]);const f=(h/2-d/o*g)/Math.sin(y),w=P(t[u-1],t[u],Math.PI-y,f,!0),v=P(t[u-1],t[u],y,f,!1);p.push(w),m.push(v)}return p.concat(m)}getArrowHeadPoints(t){const s=T(t)*this.headHeightFactor,n=t[t.length-1],o=s*this.headWidthFactor,a=s*this.neckWidthFactor,h=s*this.neckHeightFactor,c=P(t[t.length-2],n,0,s,!0),g=P(t[t.length-2],n,0,h,!0),d=P(n,c,Math.PI/2,o,!1),p=P(n,c,Math.PI/2,o,!0),m=P(n,g,Math.PI/2,a,!1),u=P(n,g,Math.PI/2,a,!0);return[m,d,n,p,u]}getPoints(){return this.points}}class rt extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"freehand");this.cesium=t,this.freehand=!0,this.setState("drawing")}getType(){return"line"}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.finishDrawing()}updateMovingPoint(t){this.points.push(t),this.setGeometryPoints(this.points),this.drawLine(),this.eventDispatcher.dispatchEvent("drawUpdate",t)}updateDraggingPoint(t,e){this.points[e]=t,this.setGeometryPoints(this.points),this.drawLine()}getPoints(){return this.points}}class at extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"freehand");this.cesium=t,this.freehand=!0,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length>2&&this.finishDrawing()}updateMovingPoint(t){this.points.push(t),this.points.length>2&&(this.setGeometryPoints(this.points),this.drawPolygon(),this.eventDispatcher.dispatchEvent("drawUpdate",t))}updateDraggingPoint(t,e){this.points[e]=t,this.setGeometryPoints(this.points),this.drawPolygon()}getPoints(){return this.points}}class ht extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"arrowLengthScale",5);l(this,"maxArrowLength",3e6);l(this,"t");this.cesium=t,this.t=.3,this.setState("drawing"),this.onDoubleClick()}getType(){return"line"}addPoint(t){this.points.push(t),this.points.length<2?this.onMouseMove():this.points.length===2&&(this.setGeometryPoints(this.points),this.drawLine())}updateMovingPoint(t){const e=[...this.points,t];let s=[];e.length===2?(this.setGeometryPoints(e),this.drawLine()):(s=this.createLine(e),this.setGeometryPoints(s))}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createLine(this.points);this.setGeometryPoints(s),this.drawLine()}createLine(t){const e=t.map(a=>this.cartesianToLnglat(a)),s=N(this.t,e),n=[].concat(...s);return this.cesium.Cartesian3.fromDegreesArray(n)}getPoints(){return this.points}}class ct extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"freehand");this.cesium=t,this.freehand=!0,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length>1&&this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t],s=this.createEllipse(e);this.setGeometryPoints(s),this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createEllipse(this.points);this.setGeometryPoints(s),this.drawPolygon()}createEllipse(t){const e=t.map(p=>this.cartesianToLnglat(p)),s=e[0],n=e[1],o=F(s,n),a=Math.abs((s[0]-n[0])/2),h=Math.abs((s[1]-n[1])/2),c=this.generatePoints(o,a,h),g=[].concat(...c);return this.cesium.Cartesian3.fromDegreesArray(g)}generatePoints(t,e,s){let[n,o,a,h]=[null,null,0,[]];for(let c=0;c<=100;c++)a=Math.PI*2*c/100,n=t[0]+e*Math.cos(a),o=t[1]+s*Math.sin(a),h.push([n,o]);return h}getPoints(){return this.points}}class lt extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"freehand");this.cesium=t,this.freehand=!0,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length===2||this.points.length>2&&this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t],s=this.createLune(e);this.setGeometryPoints(s),this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createLune(this.points);this.setGeometryPoints(s),this.drawPolygon()}createLune(t){const e=t.map(f=>this.cartesianToLnglat(f));if(e.length===2){const f=F(e[0],e[1]),w=E(e[0],f),v=P(e[0],f,Math.PI/2,w,!1);e.push(v)}let[s,n,o,a,h]=[e[0],e[1],e[2],void 0,void 0];const c=j(s,n,o),g=E(s,c),d=W(s,c),p=W(n,c);b(s,n,o)?(a=p,h=d):(a=d,h=p);let m=K(c,g,a,h);const u=[].concat(...m);return this.cesium.Cartesian3.fromDegreesArray(u)}getPoints(){return this.points}}class gt extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);this.cesium=t,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length>1&&this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t],s=this.createRectangle(e);this.setGeometryPoints(s),this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createRectangle(this.points);this.setGeometryPoints(s),this.drawPolygon()}createRectangle(t){const[e,s]=t.map(this.cartesianToLnglat),n=[...e,e[0],s[1],...s,s[0],e[1],...e];return this.cesium.Cartesian3.fromDegreesArray(n)}getPoints(){return this.points}}class dt extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);this.cesium=t,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length===3&&this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t];this.setGeometryPoints(e),e.length===2?this.addFirstLineOfTheArrow():this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t,this.setGeometryPoints(this.points),this.drawPolygon()}getPoints(){return this.points}}class ut extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);this.cesium=t,this.setState("drawing"),this.onDoubleClick()}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1&&this.onMouseMove()}updateMovingPoint(t){const e=[...this.points,t];this.setGeometryPoints(e),e.length===2?this.addFirstLineOfTheArrow():this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t,this.setGeometryPoints(this.points),this.drawPolygon()}getPoints(){return this.points}}class Pt extends M{constructor(t,e,s){super(t,e,s);l(this,"points",[]);l(this,"freehand");this.cesium=t,this.freehand=!0,this.setState("drawing")}getType(){return"polygon"}addPoint(t){this.points.push(t),this.points.length===1?this.onMouseMove():this.points.length>1&&this.finishDrawing()}updateMovingPoint(t){const e=[...this.points,t],s=this.createCircle(e);this.setGeometryPoints(s),this.drawPolygon()}updateDraggingPoint(t,e){this.points[e]=t;const s=this.createCircle(this.points);this.setGeometryPoints(s),this.drawPolygon()}createCircle(t){const e=t.map(g=>this.cartesianToLnglat(g)),s=e[0],n=e[1],o=E(s,n),a=this.generatePoints(s,o),h=[].concat(...a);return this.cesium.Cartesian3.fromDegreesArray(h)}generatePoints(t,e){let s,n,o;const a=[];for(let h=0;h<=100;h++)o=Math.PI*2*h/100,s=t[0]+e*Math.cos(o),n=t[1]+e*Math.sin(o),a.push([s,n]);return a}getPoints(){return this.points}}return{FineArrow:X,AttackArrow:U,SwallowtailAttackArrow:tt,SquadCombat:Y,SwallowtailSquadCombat:et,StraightArrow:st,CurvedArrow:it,AssaultDirection:nt,DoubleArrow:ot,FreehandLine:rt,FreehandPolygon:at,Curve:ht,Ellipse:ct,Lune:lt,Reactangle:gt,Triangle:dt,Polygon:ut,Circle:Pt}});
